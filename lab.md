# 建立一个简易的vector

- 动态内存分配
- 对象的深复制

## 限制：

1000ms

65536K

## 语言：

C++ 语言

## 描述：
我们已经使用过STL 的vector 容器了，它相对于数组和裸指针，在开发效率和安全性上具有非常明显的优势，体现了面向对象的程序设计思想的一个重要特性：封装性。
现在，你已经学习了必要的知识，来自己设计一个`vector`类吧！虽然这听起来有些太难了——事实上如果你想要完整地复制出一个STL 中的vector ，那么你也确实需要学习更多的关于面向对象程序设计和数据结构的知识，但是正所谓“千里之行，始于足下”，现在你已经掌握的知识是可以建立一个简单的`vector`类的——虽然代码量有点大，也有点难度，但你是可以做到的。
简而言之，你需要实现一个`vector`类——对于以下给定的主函数，它应该能给出正确的输出：
```C++
int main(){
    vector v1(5);
    for (int i = 0; i <7 ; ++i) {
        v1.insert(i);
    }
    v1.show();
    vector v2(v1);
    int input;
    cin>>input;
    v2.insert(input);
    v2.show();
    v1.show();
    v2.sort_array();
    v2.show();
    return 0;
}
```
注意不要修改主函数的代码！否则可能导致你的代码不能通过判题。
## 样例输入
```C++
3
```

## 样例输出：
```C++
0 1 2 3 4 5 6
0 1 2 3 4 5 6 3
0 1 2 3 4 5 6
0 1 2 3 3 4 5 6
```

## 提示信息：
这个题目涉及到一点超出本课程范围的数据结构知识——这里将这部分内容直接以提示形式给出：
1. 我们可以看出，这个类的`insert`方法，跟STL vector 的`push_back`方法基本一致——要实现这个方法，我们需要注意以下两点：
- 一方面，我们需要一个单独的成员变量来记录下一次需要插入的位置——比如如果一个`vector`对象还没有元素，那么下一次需要插入的位置就是0，而如果有3个元素的话下一次需要插入的位置就是3（别忘了数组是从0开始计数的）
- 另一方面，每次执行插入的时候我们都需要判断下一次插入的位置是否会导致数组越界——如果越界就要对数组进行扩容。我们都知道，C++ 并没有提供扩充数组容量的函数——不过这个问题说难也难，说不难也不难。所谓“要把大象放进冰箱里，一共分为三步”，我们扩充一个数组的容量，也会需要三步：第一步，建立一个临时的“备份数组”，把原来储存的数据都备份过去；第二步，删掉原来的数组，并且在原来的指针上动态分配建立一个新的数组，容量为原数组的两倍（为什么是两倍？大家有兴趣可以继续学习数据结构课程）；第三步，把“备份数组”的数据还原到新建立的扩容数组中，然后删掉旧的数组
2. 对于`sort_array`方法，如何实现排序算法需要数据结构的知识——但是这里我们不用自己实现算法，直接调用STL 提供的`sort`函数即可，它位于头文件`<algorithm>`中——具体用法大家可以自行查阅相关文档
3. 为了确保输出格式正确，对于类的`show`方法，大家可以参照以下代码：
```C++
void show(){
    for (int i = 0; i <number ; ++i) {
        cout<<data[i]<<" ";
    }
    cout<<endl;
}
```
